\section{Algorithm to Construct a Lower Bound $m(d, k)$}

We now provide an algorithm that takes as an input a set of generators as well as two other permutation sets. These inputs are used to test the ability of a generated lower bound to provide a set covering for our Cayley Graph. The algorithm iterates through permutations of the generating set and possible coverings, giving as an output the maximal generating set as well as the optimal polynomial bound.

\noindent
The algorithm takes advantage of the fact that there exists a one-to-one correspondance between representations of the residual classes of $\mathbb{Z}_{m}$ and the set of integers $[0, m-1]$.\n

\subsection{Polynomial Construction}
\noindent
Let $d$ be the diameter for $\Cay(m, \mathcal{A})$.\n 

\subsubsection{Permutations of Generators and Coefficients}
The algorithm producing generators and coefficients with which the lower bound is constructed is the heart of functionality for the algorithm. \n
The permutations tested may be stored as data structures or file tables.

\noindent
Given $d$ define \emph{\bf{$d_{1}$ fixed}} to be $\frac{d}{\lambda}$.\n

\noindent
The purpose of the following data structures is to provide containers for the following:\n
Define $\mathcal{A}$ to be a \emph{set of generators}, $\mathcal{A} = \{ (a_{i}) \vert a_{i+1} = \alpha_{i}a_{i},  \forall i \in [0, k-1] \} $, with $a_i$ a sequence of nonnegative coefficients, and $\vert \mathcal{A} \vert = k$.\n
Define a \emph{set of non-negative coefficients} $c_{1}, c_{2}, .. , c_{k}$ such that $a_{i+1} = \alpha_{i}a_{i} \lambda$, where ($\alpha_{i}$) is any sequence of coefficients.\n
Lastly, define a \emph{second set of non-negative coefficients} $x_{1}, x_{2}, .., x_{k}$ such that $x_{i+1} < d - \sum_{0}^{i}x_{i}$.

\noindent
Assume that the set of generator combinations is defined as an unordered list of tuples, the sequences of coefficients are defined as ordered lists of tuples.

\subsubsection*{Tuple Data Structure}

\begin{lstlisting}

template<TP, N>
class Tuple{

    vector<TP> data; // class contains an N-vector of type TP

    ...
};

\end{lstlisting}

\subsubsection*{Construction of the Permutations}

\begin{lstlisting}

typedef Tuple<int, k> T;


// Construction of X-Coefficients
for(x1 = d; x1 >= 0; --x1)
{
  for(x2 = d - x1; x2 >= 0; --x2)
  {
     for(x3 = d - x1 - x2; x3 >= 0; --x3) 
     {
    
        ...
            
            for(xn = d - x1 - x2 - x3 - .. - xn; xn >= 0; --xn)
            {
                 if(x1 + x2 + x3 + .. +xn <= d - k)
                 {
                      out << T(xx, xn-1, .. , x1); // In this case we are storing in a data file.
                      ++size;
                 }
            }

        ...
     }	
  }
}

// Construction of M-Coefficients
for(int c1 = 1; c1 < (d^k / (k! * a1 * a2 * .. * an-1)); ++c1)
{
  for(int c2 = 1; c2 < a1; ++c2)
  {
     for(int c3 = 1; c3 < a2; ++c3)
     {

         ...

             for(cn = 1; cn < an-1; ++cn)
             {

                 out << T(cn, cn-1, .. , c1) ;
                 ++size;
             }

         ...
     }
  }
}

// Construction of Generators
for(a1 = 2; a1 < (d^k / k!); a1++) // We are using the trivial lower bound to constrain the size of the generators.
{
  for(a2 = 2; a2 < (d^k / k!); a2++)
  {
        ...

             if(a1 * a2 * .. * an-1 < d^k / k!)
             {
                 out<< T(a1 * a2 *.. * an-1, a2 * a3 * .. an-1, ... , an-1, 1);
                 ++size;
             }
        ...
  }
}


\end{lstlisting}

\subsubsection{Polynomial Construction}

Our lower bound on $m(d, k)$ will be defined as $m(d, k) = a_{i}c_{i} \lambda$. To determine the validity of the lower bound, we compute every point in $d \mathcal{A}$ as a polynomial in terms of $\lambda$.\n
Let $ \{ (x_{1}, x_{2}, ... , x_{n}) \vert x_{1} \leq c_{1}, x_{2} \leq c_{2}, .. , x_{k} \leq c_{k}$, and $\sum_{i} x_{i} \leq d_{1} \}$ define polynomials $x$ that are considered to be minimal.\n

\begin{lstlisting}

Polynomial P(Tuple A, Tuple Y);

\end{lstlisting}

($\lambda$ is a large number determined by $d$. The parameter $\lambda$ will not appear in the code, but it enables us to compute a lower bound as a function of $d$.)\n

\subsection*{Polynomial Data Structure} The basic polynomial data structure may be defined as follows:

\begin{lstlisting}

class Polynomial{

    Tuple A;  // container for Generators
    Tuple Y;  // container for M-Coefficients or X-Coefficients

    ...
};

\end{lstlisting}

In the case where Polynomial P.Y is a container for the M-Coefficients, the class instance is a representation of the polynomial $x$. In the case where P.Y is a container for the X-Coefficients, the class instance is a representation of $X'$.
P.Y[0] will refer to the largest polynomial coefficient. P.A[0] will refer to the largest corresponding generator.

\subsubsection{Construction of the Polynomial Bound}

For all constructed polynomials $x = x_{1}a_{1} + x_{2}a_{2} + .. + x_{k}a_{k}$, we define a representative $x' \in [1, m-1]$ to which we will map all congruent polynomials, forming our residue class $\bar{x}$ of regular polynomials.\n

\begin{lstlisting}

\\ Define a class function to return the summation of our polynomial bound.
TP Polynomial::value()
{
    return (x1*y1 + x2*y2 +   + xk*yk);
}

\end{lstlisting}

\noindent
Let $ \{ (x_{1}, x_{2}, ... , x_{n}) \vert x_{1} \leq c_{1}, x_{2} \leq c_{2}, .. , x_{k} \leq c_{k}$, and $\sum_{i} x_{i} \leq d_{1} \}$ define polynomials $x$ that are considered to be minimal.\n
The constructed polynomial $x$ is defined to be regular if $x \in [0, m-1]$. In this way we are able to check $d \mathcal{A} = \mathbb{Z}_{m}$ by only considering a single covering of $\mathbb{Z}_{m}$.\n
Note that a regular polynomial need not be minimal.\n
We check for regularity by comparing the coefficients $(x_{1}, x_{2}, x_{3}, .. , x_{k})$ and $(c_{1}, c_{2}, .. , c_{k})$ from their respective polynomials.\n

\noindent
$\forall x \in d \mathcal{A}$ if $x \notin [0, m-1]$, we can identify $x$ with point $x' = (x'_{1}, x'_{2}, .. , x'_{k}) \in [0, m-1]$ congruent to $x$ $(mod$ $m)$.  Then if every point $n \in \mathbb{Z}_{m}$ is either equal to some $x$ or $x'$, then $d \mathcal{A} \cong \mathbb{Z}_m$.\n

Consider the case, $x > m(d, k)$, where $x$ is not regular. We perform a recursive polynomial subtraction of the coefficients where $c_{1}, c_{2}, c_{3}$ is subtracted term-by-term from $x_{1}, x{2}, x{3}, ... , x_{n}$. The resulting low-order coefficients are then forced to be positive by adding the generator associated with the next higher-order term.\n

For example, a resulting polynomial that has been forced to be well formed may look as, $[\lambda(x_{1} - 2 c_{1}) + 1]a_{1} + [\lambda(x_{2} - 2 c_{2}) + 2]a_{2} + [\lambda(x_{3} - 2 c_{3}) + 1]a_{3} + ... + [\lambda(x_{k} - 2 c_{k}) + 3]a_{k}$.\n

\begin{lstlisting}

    loop:
    while( Y > rhs.Y )
    {
          Y = T(Y[0] - rhs.Y[0], Y[1] - rhs.Y[1], Y[2] - rhs.Y[2], ... , Y[k] - rhs.Y[k]);
    }
    while( Y[1] < 0 )
    {
          Y = T(Y[0], Y[1] + (A[0] / A[1]), Y[2], ... , Y[k]);
    }
    while( Y[2] < 0 )
    {
          Y = T(Y[0], Y[1], Y[2] + (A[1] / A[2]), ... , Y[k]);
    }
    while( Y[3] < 0 )
    {
          Y = T(Y[0], Y[1], Y[2], Y[3] + (A[2] / A[3]), ... , Y[k]);
    }


    ...


    while( Y[k] < 0 )
    {
         Y = T(Y[0], Y[1], Y[2], Y[3] + (A[2] / A[3]), ... , Y[k] + (A[k-1] / A[k]));

    }
    if( Y > rhs.Y ){ goto loop; } 


    return *this;

\end{lstlisting}


To construct a lower bound, we systematically check combinations of generators $\mathcal{A}$ and coefficients, and record the largest $m$ (and corresponding generators) such that a covering by $d \mathcal{A}$ is achieved.

$\forall n \in \mathbb{Z}_{m}$, where n is the residue class of $\mathbb{Z}_{m}$, if $\exists  x$ such that $\bar{x} = \bar{x'}= n$, then $d \mathcal{A} = \mathbb{Z}_{m}$.\n


